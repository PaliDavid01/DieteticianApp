//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class MaterialService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllFasz(): Observable<Material[]> {
        let url_ = this.baseUrl + "/Material/GetAllFasz";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFasz(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFasz(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Material[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Material[]>;
        }));
    }

    protected processGetAllFasz(response: HttpResponseBase): Observable<Material[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Material.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(material: MaterialPostDTO): Observable<void> {
        let url_ = this.baseUrl + "/Material";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(material);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(material: Material): Observable<void> {
        let url_ = this.baseUrl + "/Material";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(material);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Material?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoleService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    createRole(role: Role): Observable<Role> {
        let url_ = this.baseUrl + "/api/Role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Role>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Role>;
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<Role> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRoles(): Observable<Role[]> {
        let url_ = this.baseUrl + "/api/Role";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Role[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Role[]>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<Role[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Role.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createUserRole(userRole: UserRole): Observable<UserRole> {
        let url_ = this.baseUrl + "/api/Role/CreateUserRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userRole);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUserRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUserRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRole>;
        }));
    }

    protected processCreateUserRole(response: HttpResponseBase): Observable<UserRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = UserRole.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRolesByUserId(userId?: number | undefined): Observable<UserRole[]> {
        let url_ = this.baseUrl + "/api/Role/GetRolesByUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolesByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolesByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRole[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRole[]>;
        }));
    }

    protected processGetRolesByUserId(response: HttpResponseBase): Observable<UserRole[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRole.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRoleViews(): Observable<UserRoleView[]> {
        let url_ = this.baseUrl + "/api/Role/GetRoleViews";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleViews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleViews(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRoleView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRoleView[]>;
        }));
    }

    protected processGetRoleViews(response: HttpResponseBase): Observable<UserRoleView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRoleView.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserRoleViewsByUserId(userId?: number | undefined): Observable<UserRoleView[]> {
        let url_ = this.baseUrl + "/api/Role/GetUserRoleViewsByUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRoleViewsByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRoleViewsByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRoleView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRoleView[]>;
        }));
    }

    protected processGetUserRoleViewsByUserId(response: HttpResponseBase): Observable<UserRoleView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRoleView.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserRoles(): Observable<Role[]> {
        let url_ = this.baseUrl + "/api/Role/GetUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Role[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Role[]>;
        }));
    }

    protected processGetUserRoles(response: HttpResponseBase): Observable<Role[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Role.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    login(loginUser: LoginDTO): Observable<LoginResponseDTO> {
        let url_ = this.baseUrl + "/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginUser);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponseDTO>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = LoginResponseDTO.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    register(userDTO: RegisterDTO): Observable<number> {
        let url_ = this.baseUrl + "/User/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRoles(): Observable<string[]> {
        let url_ = this.baseUrl + "/User/Roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class Material implements IMaterial {
    id?: string;
    name!: string;
    fat?: number;
    protein?: number;
    kilocalorie?: number;
    kilojoule?: number;
    carbohydrate?: number;
    cholesterol?: number;
    saturatedfat?: number;
    transfat?: number;
    natrium_mg?: number;
    fluorite_mg?: number;
    salt?: number;
    sugar?: number;
    scale?: number;
    scaleType?: number;
    updated?: Date;
    updatedBy?: string;
    allergen?: boolean;

    constructor(data?: IMaterial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.fat = _data["fat"] !== undefined ? _data["fat"] : <any>null;
            this.protein = _data["protein"] !== undefined ? _data["protein"] : <any>null;
            this.kilocalorie = _data["kilocalorie"] !== undefined ? _data["kilocalorie"] : <any>null;
            this.kilojoule = _data["kilojoule"] !== undefined ? _data["kilojoule"] : <any>null;
            this.carbohydrate = _data["carbohydrate"] !== undefined ? _data["carbohydrate"] : <any>null;
            this.cholesterol = _data["cholesterol"] !== undefined ? _data["cholesterol"] : <any>null;
            this.saturatedfat = _data["saturatedfat"] !== undefined ? _data["saturatedfat"] : <any>null;
            this.transfat = _data["transfat"] !== undefined ? _data["transfat"] : <any>null;
            this.natrium_mg = _data["natrium_mg"] !== undefined ? _data["natrium_mg"] : <any>null;
            this.fluorite_mg = _data["fluorite_mg"] !== undefined ? _data["fluorite_mg"] : <any>null;
            this.salt = _data["salt"] !== undefined ? _data["salt"] : <any>null;
            this.sugar = _data["sugar"] !== undefined ? _data["sugar"] : <any>null;
            this.scale = _data["scale"] !== undefined ? _data["scale"] : <any>null;
            this.scaleType = _data["scaleType"] !== undefined ? _data["scaleType"] : <any>null;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>null;
            this.updatedBy = _data["updatedBy"] !== undefined ? _data["updatedBy"] : <any>null;
            this.allergen = _data["allergen"] !== undefined ? _data["allergen"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): Material | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Material>(data, _mappings, Material);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["fat"] = this.fat !== undefined ? this.fat : <any>null;
        data["protein"] = this.protein !== undefined ? this.protein : <any>null;
        data["kilocalorie"] = this.kilocalorie !== undefined ? this.kilocalorie : <any>null;
        data["kilojoule"] = this.kilojoule !== undefined ? this.kilojoule : <any>null;
        data["carbohydrate"] = this.carbohydrate !== undefined ? this.carbohydrate : <any>null;
        data["cholesterol"] = this.cholesterol !== undefined ? this.cholesterol : <any>null;
        data["saturatedfat"] = this.saturatedfat !== undefined ? this.saturatedfat : <any>null;
        data["transfat"] = this.transfat !== undefined ? this.transfat : <any>null;
        data["natrium_mg"] = this.natrium_mg !== undefined ? this.natrium_mg : <any>null;
        data["fluorite_mg"] = this.fluorite_mg !== undefined ? this.fluorite_mg : <any>null;
        data["salt"] = this.salt !== undefined ? this.salt : <any>null;
        data["sugar"] = this.sugar !== undefined ? this.sugar : <any>null;
        data["scale"] = this.scale !== undefined ? this.scale : <any>null;
        data["scaleType"] = this.scaleType !== undefined ? this.scaleType : <any>null;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>null;
        data["updatedBy"] = this.updatedBy !== undefined ? this.updatedBy : <any>null;
        data["allergen"] = this.allergen !== undefined ? this.allergen : <any>null;
        return data;
    }
}

export interface IMaterial {
    id?: string;
    name: string;
    fat?: number;
    protein?: number;
    kilocalorie?: number;
    kilojoule?: number;
    carbohydrate?: number;
    cholesterol?: number;
    saturatedfat?: number;
    transfat?: number;
    natrium_mg?: number;
    fluorite_mg?: number;
    salt?: number;
    sugar?: number;
    scale?: number;
    scaleType?: number;
    updated?: Date;
    updatedBy?: string;
    allergen?: boolean;
}

export class MaterialPostDTO implements IMaterialPostDTO {
    name?: string;
    fat?: number;
    protein?: number;
    kilocalorie?: number;
    kilojoule?: number;
    carbohydrate?: number;
    cholesterol?: number;
    saturatedfat?: number;
    transfat?: number;
    natrium_mg?: number;
    fluorite_mg?: number;
    salt?: number;
    sugar?: number;
    scale?: number;
    updated?: Date;
    updatedBy?: string;

    constructor(data?: IMaterialPostDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.fat = _data["fat"] !== undefined ? _data["fat"] : <any>null;
            this.protein = _data["protein"] !== undefined ? _data["protein"] : <any>null;
            this.kilocalorie = _data["kilocalorie"] !== undefined ? _data["kilocalorie"] : <any>null;
            this.kilojoule = _data["kilojoule"] !== undefined ? _data["kilojoule"] : <any>null;
            this.carbohydrate = _data["carbohydrate"] !== undefined ? _data["carbohydrate"] : <any>null;
            this.cholesterol = _data["cholesterol"] !== undefined ? _data["cholesterol"] : <any>null;
            this.saturatedfat = _data["saturatedfat"] !== undefined ? _data["saturatedfat"] : <any>null;
            this.transfat = _data["transfat"] !== undefined ? _data["transfat"] : <any>null;
            this.natrium_mg = _data["natrium_mg"] !== undefined ? _data["natrium_mg"] : <any>null;
            this.fluorite_mg = _data["fluorite_mg"] !== undefined ? _data["fluorite_mg"] : <any>null;
            this.salt = _data["salt"] !== undefined ? _data["salt"] : <any>null;
            this.sugar = _data["sugar"] !== undefined ? _data["sugar"] : <any>null;
            this.scale = _data["scale"] !== undefined ? _data["scale"] : <any>null;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>null;
            this.updatedBy = _data["updatedBy"] !== undefined ? _data["updatedBy"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): MaterialPostDTO | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MaterialPostDTO>(data, _mappings, MaterialPostDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["fat"] = this.fat !== undefined ? this.fat : <any>null;
        data["protein"] = this.protein !== undefined ? this.protein : <any>null;
        data["kilocalorie"] = this.kilocalorie !== undefined ? this.kilocalorie : <any>null;
        data["kilojoule"] = this.kilojoule !== undefined ? this.kilojoule : <any>null;
        data["carbohydrate"] = this.carbohydrate !== undefined ? this.carbohydrate : <any>null;
        data["cholesterol"] = this.cholesterol !== undefined ? this.cholesterol : <any>null;
        data["saturatedfat"] = this.saturatedfat !== undefined ? this.saturatedfat : <any>null;
        data["transfat"] = this.transfat !== undefined ? this.transfat : <any>null;
        data["natrium_mg"] = this.natrium_mg !== undefined ? this.natrium_mg : <any>null;
        data["fluorite_mg"] = this.fluorite_mg !== undefined ? this.fluorite_mg : <any>null;
        data["salt"] = this.salt !== undefined ? this.salt : <any>null;
        data["sugar"] = this.sugar !== undefined ? this.sugar : <any>null;
        data["scale"] = this.scale !== undefined ? this.scale : <any>null;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>null;
        data["updatedBy"] = this.updatedBy !== undefined ? this.updatedBy : <any>null;
        return data;
    }
}

export interface IMaterialPostDTO {
    name?: string;
    fat?: number;
    protein?: number;
    kilocalorie?: number;
    kilojoule?: number;
    carbohydrate?: number;
    cholesterol?: number;
    saturatedfat?: number;
    transfat?: number;
    natrium_mg?: number;
    fluorite_mg?: number;
    salt?: number;
    sugar?: number;
    scale?: number;
    updated?: Date;
    updatedBy?: string;
}

export class Role implements IRole {
    roleId?: number;
    roleName?: string | null;
    roleDescription?: string | null;
    userRoles?: UserRole[] | null;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.userRoles) {
                this.userRoles = [];
                for (let i = 0; i < data.userRoles.length; i++) {
                    let item = data.userRoles[i];
                    this.userRoles[i] = item && !(<any>item).toJSON ? new UserRole(item) : <UserRole>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
            this.roleName = _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
            this.roleDescription = _data["roleDescription"] !== undefined ? _data["roleDescription"] : <any>null;
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRole.fromJS(item, _mappings));
            }
            else {
                this.userRoles = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Role | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Role>(data, _mappings, Role);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
        data["roleDescription"] = this.roleDescription !== undefined ? this.roleDescription : <any>null;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRole {
    roleId?: number;
    roleName?: string | null;
    roleDescription?: string | null;
    userRoles?: IUserRole[] | null;
}

export class UserRole implements IUserRole {
    userRoleId?: number;
    userId?: number;
    roleId?: number;
    dateAssigned?: Date;
    dateRevoked?: Date | null;
    isActive?: boolean;
    role?: Role | null;
    user?: User | null;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.role = data.role && !(<any>data.role).toJSON ? new Role(data.role) : <Role>this.role;
            this.user = data.user && !(<any>data.user).toJSON ? new User(data.user) : <User>this.user;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userRoleId = _data["userRoleId"] !== undefined ? _data["userRoleId"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
            this.dateAssigned = _data["dateAssigned"] ? new Date(_data["dateAssigned"].toString()) : <any>null;
            this.dateRevoked = _data["dateRevoked"] ? new Date(_data["dateRevoked"].toString()) : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.role = _data["role"] ? Role.fromJS(_data["role"], _mappings) : <any>null;
            this.user = _data["user"] ? User.fromJS(_data["user"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): UserRole | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserRole>(data, _mappings, UserRole);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId !== undefined ? this.userRoleId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        data["dateAssigned"] = this.dateAssigned ? this.dateAssigned.toISOString() : <any>null;
        data["dateRevoked"] = this.dateRevoked ? this.dateRevoked.toISOString() : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["role"] = this.role ? this.role.toJSON() : <any>null;
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        return data;
    }
}

export interface IUserRole {
    userRoleId?: number;
    userId?: number;
    roleId?: number;
    dateAssigned?: Date;
    dateRevoked?: Date | null;
    isActive?: boolean;
    role?: IRole | null;
    user?: IUser | null;
}

export class User implements IUser {
    userId?: number;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    passwordHash?: string | null;
    passwordSalt?: string | null;
    userRoles?: UserRole[] | null;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.userRoles) {
                this.userRoles = [];
                for (let i = 0; i < data.userRoles.length; i++) {
                    let item = data.userRoles[i];
                    this.userRoles[i] = item && !(<any>item).toJSON ? new UserRole(item) : <UserRole>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.passwordHash = _data["passwordHash"] !== undefined ? _data["passwordHash"] : <any>null;
            this.passwordSalt = _data["passwordSalt"] !== undefined ? _data["passwordSalt"] : <any>null;
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRole.fromJS(item, _mappings));
            }
            else {
                this.userRoles = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): User | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<User>(data, _mappings, User);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["passwordHash"] = this.passwordHash !== undefined ? this.passwordHash : <any>null;
        data["passwordSalt"] = this.passwordSalt !== undefined ? this.passwordSalt : <any>null;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUser {
    userId?: number;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    passwordHash?: string | null;
    passwordSalt?: string | null;
    userRoles?: IUserRole[] | null;
}

export class UserRoleView implements IUserRoleView {
    userRoleId?: number;
    userId?: number;
    roleId?: number;
    roleName?: string | null;

    constructor(data?: IUserRoleView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userRoleId = _data["userRoleId"] !== undefined ? _data["userRoleId"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
            this.roleName = _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): UserRoleView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserRoleView>(data, _mappings, UserRoleView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId !== undefined ? this.userRoleId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
        return data;
    }
}

export interface IUserRoleView {
    userRoleId?: number;
    userId?: number;
    roleId?: number;
    roleName?: string | null;
}

export class LoginResponseDTO implements ILoginResponseDTO {
    firstName?: string;
    lastName?: string;
    email?: string;
    role?: string;
    token?: string;

    constructor(data?: ILoginResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.role = _data["role"] !== undefined ? _data["role"] : <any>null;
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): LoginResponseDTO | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LoginResponseDTO>(data, _mappings, LoginResponseDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        return data;
    }
}

export interface ILoginResponseDTO {
    firstName?: string;
    lastName?: string;
    email?: string;
    role?: string;
    token?: string;
}

export class LoginDTO implements ILoginDTO {
    email?: string;
    password?: string;

    constructor(data?: ILoginDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): LoginDTO | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LoginDTO>(data, _mappings, LoginDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface ILoginDTO {
    email?: string;
    password?: string;
}

export class RegisterDTO implements IRegisterDTO {
    firstName?: string;
    lastName?: string;
    email?: string;
    password?: string;
    roleId?: number;

    constructor(data?: IRegisterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): RegisterDTO | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RegisterDTO>(data, _mappings, RegisterDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        return data;
    }
}

export interface IRegisterDTO {
    firstName?: string;
    lastName?: string;
    email?: string;
    password?: string;
    roleId?: number;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}